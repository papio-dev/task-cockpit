/** Разбиение строки на сегменты по заданному разделителю с учетом контекста.
 *
 * ## Splitter
 *
 * Разделитель срабатывает только если с обеих сторон находятся "значимые" символы
 * (не пробелы и не сам разделитель). Это предотвращает разбиение в граничных
 * случаях и при множественных разделителях.
 *
 * Пробельные символы не могут быть разделителем
 *
 * Примеры поведения (delimiter = '/'):
 * ~~~typescript
 * const splitter = new Splitter('/');
 * splitter.split('a/b/c');        // [ 'a', 'b', 'c' ]
 * splitter.split('a / b');        // [ 'a / b' ]      (пробелы рядом с /)
 * splitter.split('/a/b/');        // [ '/a', 'b/' ]     (/ в начале и конце сохраняются)
 * splitter.split('a//b');         // [ 'a//b' ]       (двойной //)
 *
 * const noSplit = new Splitter(false);
 * noSplit.split('a/b/c');         // [ 'a/b/c' ]      (разбиение отключено)
 * ~~~
 *
 * ### API
 *
 * #### Параметры конструктора:
 * - `delimiter` Символ-разделитель, пустая строка или `false` для отключения разбиения
 *
 * #### Методы:
 * - `split()` Разбивает строку на сегменты согласно правилам разделителя
 *
 * */
class Splitter {

    /** RegExp для разбиения строки на сегменты.
     *
     * Использует позитивные lookahead и lookbehind для проверки контекста:
     * - Перед разделителем должен быть "значимый" символ (не пробел, не разделитель)
     * - После разделителя должен быть "значимый" символ (не пробел, не разделитель)
     *
     * `undefined` если разбиение отключено или разделитель невалиден. */
    private readonly splitter: RegExp | undefined = undefined;


    /** Создает экземпляр Splitter с заданным разделителем.
     *
     * Разделитель обрабатывается следующим образом:
     * 1. Берется первый (*один*) символ
     * 2. Обрезаются начальные пробелы (`trimStart`), что исключает использование
     *    пробельных символов как разделителя
     * 3. Символ экранируется для использования в RegExp
     * 4. Создается RegExp с контекстными проверками
     *
     * Граничные случаи:
     * - Falsy значения → разбиение отключено, `split()` вернет массив из одного элемента
     * - Спецсимволы RegExp автоматически экранируются
     *
     * @param delimiter Символ-разделитель или `false`/`''` для отключения разбиения.
     *                  Используется только первый символ */
    constructor(delimiter: string | false) {
        if (delimiter) {
            const sanitized = (delimiter[0])?.trimStart().replace(/[.*+?^${}()|[\]\\]/, '\\$&') || false;
            if (sanitized) {
                this.splitter = new RegExp(`(?<=[^${sanitized}\\s])${sanitized}(?=[^${sanitized}\\s])`);
            }
        }
    }


    /** Разбивает строку на сегменты согласно правилам разделителя.
     *
     * Правила разбиения:
     * 1. Разделитель срабатывает только между "значимыми" символами
     * 2. "Значимый" символ — не пробел И не сам разделитель
     *
     * @param segmentsSpec Строка для разбиения на сегменты
     * @returns Массив сегментов. Если разбиение невозможно или отключено,
     *          возвращается массив из одного элемента (исходная строка). */
    public split(segmentsSpec: string): string[] {
        if (this.splitter) {
            return segmentsSpec.split(this.splitter);
        }
        return [segmentsSpec];
    }

}


export { Splitter };
